/**
 * Generated by orval v7.7.0 üç∫
 * Do not edit manually.
 * DCS Dropzone Registry
 * DCS Dropzone Registry API
 * OpenAPI spec version: 1.0.0
 */
import { useQuery } from "@tanstack/react-query";
import type {
  QueryFunction,
  QueryKey,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/react-query";

import axios from "axios";
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from "axios";

export type RegistryIndexItemAuthorsItem = {
  name: string;
  avatar?: string;
  url?: string;
};

export type RegistryIndexItem = {
  /** The name of the mod */
  name?: string;
  /** A short description of the mod to be displayed in the mod tile */
  description?: string;
  authors: RegistryIndexItemAuthorsItem[];
  /** The tags of the mod, these are used to filter mods in the mod browser */
  tags: string[];
  /** The category of the mod, this is used to group mods in the mod browser */
  category?: string;
  latest?: string;
  /** The dependencies of the mod */
  dependencies?: string[];
  /** @pattern ^[a-z0-9-]+$ */
  id: string;
  imageUrl: string;
};

export type RegistryIndex = RegistryIndexItem[];

export type EntryIndexAuthorsItem = {
  name: string;
  avatar?: string;
  url?: string;
};

export type EntryIndexVersionsItemAssetsItemLinksItem = {
  /** The name of the file # separates download path and internal zip path */
  source?: string;
  /** The name of the installation location relative to install path */
  target?: string;
  /** Run on simulation (mission) start, note that this will execute the script before the mission environment is sanitized */
  runonstart?: boolean;
};

export type EntryIndexVersionsItemAssetsItem = {
  /** The URL of the file to download */
  remoteSource?: string;
  links: EntryIndexVersionsItemAssetsItemLinksItem[];
};

export type EntryIndexVersionsItem = {
  /** The release page of the release */
  releasepage: string;
  /** The name of the release */
  name?: string;
  /** The version of the release */
  version?: string;
  /** The date of the release */
  date: string;
  /** Executable file specifically Tools */
  exePath?: string;
  /** The array of files to install */
  assets: EntryIndexVersionsItemAssetsItem[];
};

export interface EntryIndex {
  /** The homepage of the mod */
  homepage: string;
  /** The name of the mod */
  name?: string;
  /** A short description of the mod to be displayed in the mod tile */
  description?: string;
  authors: EntryIndexAuthorsItem[];
  /** The tags of the mod, these are used to filter mods in the mod browser */
  tags: string[];
  /** The category of the mod, this is used to group mods in the mod browser */
  category?: string;
  /** The license of the mod */
  license?: string;
  latest?: string;
  /** The dependencies of the mod */
  dependencies?: string[];
  /** The versions of the mod */
  versions: EntryIndexVersionsItem[];
  /** @pattern ^[a-z0-9-]+$ */
  id: string;
  imageUrl: string;
  content: string;
}

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

/**
 * @summary Get Registry Index
 */
export const getRegistryIndex = (
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<RegistryIndex>> => {
  return axios.get(
    `/api/registry/index.json`,
    options,
  );
};

export const getGetRegistryIndexQueryKey = () => {
  return [`/api/registry/index.json`] as const;
};

export const getGetRegistryIndexQueryOptions = <
  TData = Awaited<ReturnType<typeof getRegistryIndex>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getRegistryIndex>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRegistryIndexQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRegistryIndex>>> = (
    { signal },
  ) => getRegistryIndex({ signal, ...axiosOptions });

  return { queryKey, queryFn, ...queryOptions } as
    & UseQueryOptions<
      Awaited<ReturnType<typeof getRegistryIndex>>,
      TError,
      TData
    >
    & { queryKey: QueryKey };
};

export type GetRegistryIndexQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRegistryIndex>>
>;
export type GetRegistryIndexQueryError = AxiosError<unknown>;

/**
 * @summary Get Registry Index
 */

export function useGetRegistryIndex<
  TData = Awaited<ReturnType<typeof getRegistryIndex>>,
  TError = AxiosError<unknown>,
>(
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getRegistryIndex>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRegistryIndexQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Get Registry Entry
 */
export const getRegistryEntry = (
  id: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<EntryIndex>> => {
  return axios.get(
    `/api/registry/${id}/index.json`,
    options,
  );
};

export const getGetRegistryEntryQueryKey = (id: string) => {
  return [
    `/api/registry/${id}/index.json`,
  ] as const;
};

export const getGetRegistryEntryQueryOptions = <
  TData = Awaited<ReturnType<typeof getRegistryEntry>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getRegistryEntry>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetRegistryEntryQueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getRegistryEntry>>> = (
    { signal },
  ) => getRegistryEntry(id, { signal, ...axiosOptions });

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as
    & UseQueryOptions<
      Awaited<ReturnType<typeof getRegistryEntry>>,
      TError,
      TData
    >
    & { queryKey: QueryKey };
};

export type GetRegistryEntryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getRegistryEntry>>
>;
export type GetRegistryEntryQueryError = AxiosError<unknown>;

/**
 * @summary Get Registry Entry
 */

export function useGetRegistryEntry<
  TData = Awaited<ReturnType<typeof getRegistryEntry>>,
  TError = AxiosError<unknown>,
>(
  id: string,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getRegistryEntry>>,
      TError,
      TData
    >;
    axios?: AxiosRequestConfig;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetRegistryEntryQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
